# Concurrency Control

## Lock-Based Protocols

- A lock is a mechanism to control **concurrent access** to a data item

- Data items can be locked in two modes:
  - **exclusive** *(X) mode*. Data item can be both read as well as written. X-lock is requested using **lock-X** instruction
  - **shared** *(S) mode*. Data item can only be read. S-lock is requested using **lock-S** instruction
- Lock requests are made to **concurrency-control manager**. Transaction can proceed only after request is **granted**
- **Lock-compatibility matrix**

<img src="https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079430.png" alt="image-20211116174847325" style="zoom:67%;" />

- Any number of transactions can hold **shared locks** on an item
- But if any transaction holds an **exclusive** on the item no other transaction may hold any lock on the item
- A **locking protocol** is a set of rules followed by all transactions while **requesting and releasing locks**
- Locking protocols enforce **serializability** by restricting the set of possible schedules



### Deadlock

- **Starvation** is also possible if concurrency control manager is badly designed. For example:
  - A transaction may be waiting for an X-lock on an item, while a sequence of other transactions request and are granted an S-lock on the same item
  - The same transaction is repeatedly rolled back due to deadlocks.



### The Two-Phase Locking Protocol

- A protocol which ensures **conflict-serializable** schedules
- **Growing Phase**: Transaction may obtain locks & not release locks
- **Shrinking Phase**: Transaction may release locks & not obtain locks
- The protocol assures serializability. Two-phase locking is not a necessary condition for serializability
- It can be proved that the transactions can be serialized in the order of their **lock points** (i.e., the point where a transaction acquired its final lock)

![image-20211123173931086](https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079427.png)

- Two-phase locking *does not* ensure freedom from deadlocks

- Extensions to basic two-phase locking needed to ensure recoverability of freedom from cascading roll-back
  - **Strict two-phase locking:** a transaction must hold **all its exclusive locks** till it commits/aborts. Ensures **recoverability** and **avoids cascading roll-backs**
  - **Rigorous two-phase locking**: a transaction must hold ***all* locks** till commit/abort. Transactions can be serialized in the order in which they **commit**



### Locking Protocols

- A schedule S is **legal** under a locking protocol if it can be generated by a set of transactions that follow the protocol
- A protocol **ensures** serializability if all legal schedules under that protocol are serializable



### Lock Conversions

- Two-phase locking protocol with **lock conversions**:
  - Growing Phase:
    - can acquire a lock-S on item
    - can acquire a lock-X on item
    - can **convert** a lock-S to a lock-X (**upgrade**)
  - Shrinking Phase:
    - can release a lock-S
    - can release a lock-X
    - can convert a lock-X to a lock-S (**downgrade**)
- This protocol ensures serializability



### Implementation of Locking

- A **lock manager** can be implemented as a **separate process**
- Transactions can send lock and unlock requests as **messages**
- The lock manager replies to a lock request by sending a **lock grant messages** (or a message asking the transaction to roll back, in case of a deadlock)
- The requesting transaction waits until its request is answered
- The lock manager maintains an in-memory data-structure called a **lock table** to record granted locks and pending requests



### Lock Table

<img src="https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079424.png" alt="image-20211123175941269" style="zoom: 50%;" />

- **Dark** rectangles indicate **granted** locks, **light** colored ones indicate **waiting** requests
- Lock table also records the **type** of lock granted or requested
- New request is added to the end of the queue of requests for the data item, and granted if it is compatible with all earlier locks
- Unlock requests result in the request being deleted, and later requests are checked to see if they can now be granted
- If transaction aborts, all waiting or granted requests of the transaction are deleted, lock manager may keep a **list** of locks held by each **transaction**, to implement this efficiently



### Graph-Based Protocols

- Graph-based protocols are an **alternative** to **two-phase** locking
- Tree Protocol
  - The first lock by *Ti* may be on any data item. Subsequently, a data *Q* can be locked by *Ti* only if the **parent** of *Q* is currently locked by ***Ti***
  - Data items may be **unlocked** at any time
  - A data item that has been **locked and unlocked** by *Ti* cannot subsequently be relocked by *Ti*
- The tree protocol ensures conflict **serializability** as well as freedom from **deadlock** (Compared to two-phase locking)
- Unlocking may occur earlier in the tree-locking protocol than in the two-phase locking protocol
  - Shorter **waiting times**, and increase in **concurrency**
  - Protocol is deadlock-free, no rollbacks are required
- Drawbacks
  - Protocol does not guarantee **recoverability** or **cascade freedom**
    - Need to introduce **commit dependencies** to ensure recoverability
  - Transactions may have to lock data items that they do not access
    - increased locking **overhead**, and additional **waiting** time
    - potential decrease in **concurrency**
- Schedules not possible under two-phase locking are possible under the tree protocol, and vice versa



### Deadlock Prevention

- **Deadlock prevention** protocols ensure that the system will *never* enter into a deadlock state
- 方法一：同时获得所有的锁或对加锁请求进行排序
  - Require that each transaction locks **all its data items** before it begins execution (pre-declaration)
  - Impose **partial ordering** of all data items and require that a transaction can lock data items only in the order specified by the partial order (graph-based protocol)
- 方法二：事务回滚
  - **wait-die** scheme (non-preemptive)
    - **Older** transaction may **wait** for younger one to release data item
    - **Younger** transactions never wait for older ones; they are **rolled back** instead
    - A transaction may die several times before acquiring a lock
  - **wound-wait** scheme (preemptive)
    - Older transaction *wounds* (**forces rollback**) of **younger** transaction instead of waiting for it
    - **Younger** transactions may **wait** for older ones
    - **Fewer rollbacks** than *wait-die* scheme
  - Ensures that **older** transactions have **precedence** over newer ones, and **starvation** is thus **avoided**
  - **Timeout-Based Schemes**
    - A transaction waits for a lock only for a specified amount of time. After that, the wait times out and the **transaction** is **rolled back**
    - Ensures that **deadlocks** get **resolved** by timeout if they occur
    - But may roll back transaction **unnecessarily** in absence of deadlock
    - Simple to implement but difficult to determine good value of the timeout interval
    - **Starvation** is also possible



### Deadlock Detection

- The system is in a deadlock state if and only if the wait-for graph has a **cycle**
- Invoke a deadlock-detection algorithm **periodically** to look for cycles

<img src="https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079421.png" alt="image-20211123204808864" style="zoom:67%;" />



### Deadlock Recovery

- When deadlock is detected, some transaction will have to rolled back (made a **victim**) to break deadlock cycle
- Select that transaction as victim that will **incur minimum cost**
- Rollback: determine how far to roll back transaction
  - **Total rollback**: **Abort** the transaction and then restart it
  - **Partial rollback**: Roll back victim transaction only as far as necessary to **release locks** that another transaction in cycle is waiting for
- **Starvation** can happen. One solution is oldest transaction in the deadlock set is never chosen as victim



### Multiple Granularity

- Allow data items to be of various sizes and define a hierarchy of data granularities, where the small granularities are nested within larger ones
- Can be represented graphically as a tree (**but don't confuse with tree-locking protocol**)
- When a transaction locks a node in the tree *explicitly*, it *implicitly* locks all the node's **descendants** in the same mode
- Granularity of locking (level in tree where locking is done):
  - **Fine granularity** (lower in tree): high concurrency, high locking overhead
  - **Coarse granularity** (higher in tree): low locking overhead, low concurrency
- The levels, starting from the coarsest (top) level are *database*, *area*, *file* & *record*

<img src="https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079418.png" alt="image-20211123205239359" style="zoom: 50%;" />



### Intention Lock Modes

- In addition to S and X lock modes, there are three additional lock modes with multiple granularity:
  - **intention-shared** (IS): indicates **explicit** locking at a **lower level** of the tree but only with **shared** locks
  - **intention-exclusive** (IX): indicates **explicit** locking at a **lower level** with **exclusive or shared** locks
  - **shared and intention-exclusive** (SIX): the subtree rooted by that node is locked **explicitly in shared mode** and **explicit** locking is being done at a **lower level with exclusive-mode locks**
- Intention locks allow a **higher level node** to be locked in S or X mode without having to check all descendent nodes
- The compatibility matrix for all lock modes is: 

<img src="https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079416.png" alt="image-20211123233936642" style="zoom:80%;" />



### Multiple Granularity Locking Scheme

- Transaction *Ti* can lock a node *Q*, using the following rules:
  - The lock compatibility **matrix** must be observed
  - The **root** of the tree must be locked first, and may be locked in **any** mode
  - A node *Q* can be locked by *Ti* in S or IS mode only if the **parent** of *Q* is currently locked by *Ti* in either IX or IS mode
  - A node *Q* can be locked by *Ti* in X, SIX, or IX mode only if the **parent** of *Q* is currently locked by *Ti* in either IX or SIX mode
  - *Ti* can lock a node only if it has not previously unlocked any node (that is, *Ti* is **two-phase**)
  - *Ti* can **unlock** a node *Q* only if none of the **children** of *Q* are currently locked by *Ti*
- Observe that locks are acquired in **root-to-leaf** order, whereas they are released in **leaf-to-root** order
- **Lock granularity escalation**: in case there are too many locks at a particular level, switch to higher granularity S or X lock



## Timestamp-Based Protocols

- Each transaction *Ti* is issued a timestamp TS(*Ti*) when it enters the system. Each transaction has a ***unique*** timestamp. Newer transactions have timestamps strictly greater than earlier ones
- **time-stamp order = serializability order**



### Timestamp-Ordering (TSO) Protocol

- Maintains for each data *Q* two timestamp values:
  - **W-timestamp**(*Q*) is the largest time-stamp of any transaction that executed **write**(*Q*) successfully
  - **R-timestamp**(*Q*) is the largest time-stamp of any transaction that executed **read**(*Q*) successfully
- Imposes rules on read and write operations to ensure that
  - Any conflicting  operations are executed in timestamp order
  - Out of order operations cause transaction rollback
- Suppose a transaction Ti issues a **read**(*Q*)
  - If TS(*Ti*) < **W**-timestamp(*Q*), then *Ti* needs to read a value of *Q* that was already overwritten. Hence, the **read** operation is rejected, and *Ti*  is rolled back
  - If TS(*Ti*) ≥ **W**-timestamp(*Q*), then the **read** operation is executed, and R-timestamp(*Q*) is set to **max**(R-timestamp(*Q*), TS(*Ti*))
- Suppose that transaction *Ti* issues **write**(*Q*)
  - If TS(*Ti*) < R-timestamp(*Q*), then the value of *Q* that *Ti* is producing was needed previously, and the system assumed that that value would never be produced. Hence, the **write** operation is rejected, and *Ti* is rolled back
  - If TS(*Ti*) < W-timestamp(*Q*), then *Ti* is attempting to write an obsolete value of *Q*. Hence, this **write** operation is rejected, and *Ti* is rolled back
  - Otherwise, the write** operation is executed, and W-timestamp(*Q) is set to TS(*Ti*)



### Correctness of Timestamp-Ordering Protocol

- The timestamp-ordering protocol guarantees **serializability** since all the arcs in the precedence graph are of the form below, thus there will be no cycles in the precedence graph

<img src="https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079413.png" alt="image-20211130104004438" style="zoom:67%;" />

- Timestamp protocol ensures **freedom** **from** **deadlock** as no transaction ever waits
- But the schedule may not be **cascade-free**, and may not even be **recoverable**



### Recoverability and Cascade Freedom

- Solution 1:
  - A transaction is structured such that its **writes** are all performed at the **end** of its processing
  - All writes of a transaction form an **atomic action**; no transaction may execute while a transaction is being written
  - A transaction that **aborts** is restarted with a **new** **timestamp**
- Solution 2:
  - Limited form of locking: wait for data to be **committed** before **reading** it
  - **Cascadeless** **schedules**: cascading rollbacks cannot occur; For each pair of transactions *Ti* and *Tj* such that *Tj* reads a data item previously written by *Ti*, the **commit** operation of *Ti*  appears **before** the **read** operation of *Tj*
- Solution 3:
  - Use **commit dependencies** to ensure recoverability
  - **Recoverable** **schedule**: if a transaction *Tj* reads a data item previously written by a transaction *Ti*, then the **commit** operation of *Ti* appears **before** the **commit** operation of *Tj*



### Thomas' Write Rule

- When *Ti* attempts to write data item *Q*, if TS(*Ti*) *<* W-timestamp(*Q*), then *Ti* is attempting to write an obsolete value of {*Q*}. Rather than rolling back *Ti* as the timestamp ordering protocol would have done, this {write} operation can be **ignored**
- Thomas' Write Rule allows greater potential **concurrency**

- Allows some **view-serializable** schedules that are **not conflict-serializable**



## Validation-Based Protocols

- Postpone **writes** to **end** of transaction
- Keep track of data items read/written by transaction
- **Validation** performed at commit time, detect any **out-of-serialization** order reads/writes
- Also called as **optimistic concurrency control** since transaction executes fully in the hope that all will go well during validation
- Execution of transaction *Ti* is done in three phases
  - **1. Read and execution phase**: Transaction *Ti* writes only to **temporary local variables**
  - **2. Validation phase**: Transaction *Ti* performs a '‘validation test'' to determine if local variables **can be written without violating serializability**
  - **3. Write phase**: If *Ti* is validated, the updates are applied to the database; otherwise, Ti is rolled back

- The three phases of concurrently executing transactions can be  **interleaved**, but each transaction must go through the three phases in that order

- We assume for simplicity that the validation and write phase occur together, atomically and serially. Only one transaction executes **validation/write** at a time

- Each transaction Ti has 3 timestamps

  - **StartTS**(Ti) : the time when Ti started its execution
  - **ValidationTS**(Ti): the time when Ti entered its validation phase
  - **FinishTS**(Ti) : the time when Ti finished its write phase

- TS(Ti) = ValidationTS(Ti)

- Validation-based protocol has been found to give greater degree of **concurrency** than locking/TSO if probability of conflicts is low

- If for all *Ti* with TS (*Ti*) < TS (*Tj*) either one of the following condition holds:

  - **finishTS**(*Ti*) < **startTS**(*Tj*)
  - **startTS**(*Tj*) < **finishTS**(*Ti*) < **validationTS**(*Tj*) **and** the set of data items **written** by *Ti* does **not intersect** with the set of data items **read** by *Tj*

  then validation succeeds and *Tj* can be committed

- Otherwise, validation fails and *Tj* is aborted

<img src="https://raw.githubusercontent.com/ailianligit/images/main/images/202308/20230804_1691079409.png" alt="image-20211130110130646" style="zoom: 50%;" />

## Multiversion Schemes

- Each successful **write** results in the creation of a **new version** of the data item written
- Use **timestamps** to label versions
- When a **read**(*Q*) operation is issued, select an appropriate version of *Q* based on the timestamp of the transaction issuing the read request, and return the value of the selected version
- **read**s **never have to wait** as an appropriate version is returned immediately



### Multiversion Timestamp Ordering

- Each data item *Q* has a sequence of versions <*Q**1**, Q**2**,....,* *Qm*>. Each version *Qk* contains three data fields:
  - **Content**: the value of version Qk
  - **W-timestamp**(*Qk*): timestamp of the transaction that created (wrote) version Qk
  - **R-timestamp**(*Qk*): largest timestamp of a transaction that successfully read version Qk
- Suppose that transaction *Ti* issues a **read**(*Q*) or **write**(*Q*) operation. Let *Qk* denote the version of *Q* whose write timestamp is the **largest write timestamp less than or equal to** TS(*T*i)
  - If transaction *Ti* issues a **read**(*Q*), then the value returned is the content of version Qk. If R-timestamp(Qk) < TS(*Ti*), set R-timestamp(Qk) = TS(*Ti*)
  - If transaction *Ti* issues a  **write**(*Q*)
    - if TS(*Ti*) *<* R-timestamp(*Qk*), then transaction *Ti* is rolled back
    - if TS(*T*i) *=* W-timestamp(*Qk*), the contents of *Qk* are overwritten
    - Otherwise, a new version Qi of *Q* is created. W-timestamp(Qi) and R-timestamp(Qi) are initialized to TS(*Ti*)
- Protocol guarantees **serializability**



## Explanation

### 基于锁的协议

- 互斥锁和共享锁的定义3
- 锁协议的定义6
- 死锁的定义7
- 饥饿的定义8
- 两阶段锁协议的定义9：不保证不死锁
- 严格两阶段锁协议的定义9：保证可恢复性、避免级联回滚
- 强两阶段锁协议的定义9：可串行
- 锁管理器和锁表的定义17
- 基于图的协议的定义18
- 基于图的协议的优缺点20：保证冲突可串行、避免死锁、缩短等待时间、增加并行度

- 死锁预防的策略22-24：提前声明、基于图、wait-die、wound-wait、锁超时
- 死锁检测的方法25：等待图
- 死锁恢复的方法26：完全回滚和部分回滚
- 多粒度的定义27
- 多粒度的层次结构29：数据库、区域、文件、记录



### 基于时间戳的协议

- 基于时间戳的协议40
- 基于时间戳的读操作42
- 基于时间戳的写操作43
- 基于时间戳的协议的优缺点46：视图和冲突可串行、避免死锁
- 托马斯写规则48：仅视图可串行



### 基于验证的协议

- 基于验证的协议的定义49：可串行、避免级联回滚
- 基于验证的协议的三阶段50：读和执行阶段、验证阶段、写阶段
