### 死锁的定义

- 互为条件的进程陷入的无限等待状态



### 区分临界区的条件和死锁的条件

- 临界区的条件：互斥、前进和有限等待
- 死锁的条件：互斥、占有和等待、非抢占、循环等待



### 处理死锁的方法（思路）

- 预防和避免
- 检测和恢复
- 忽视死锁的问题



### 死锁预防的原理

- 通过使死锁的某一个或多个条件不成立来预防死锁



### 死锁的预防及其特点

- 互斥：在只读类型的共享资源中无需互斥，但是在**非共享资源**中需要互斥

- 占有和等待：在**开始运行前**请求和分配得到所有的资源；当前**没有资源**才能申请资源

  资源利用率低；饥饿现象

- 非抢占：如果请求不能得到满足，则**释放**当前持有的资源；被其他进程抢占的资源被添加到当前进程等待分配的**队列**中；进程只有在重新获得旧资源和获得新请求的资源后才能**重新启动**

- 循环等待：对所有的资源进行**排序**，要求每个进程以**递增顺序请求**资源

  唯一可行



### 死锁避免的原理和方法分类

- 原理：死锁避免算法动态检查资源分配状态，保证系统永远不会进入不安全的状态
- 每个资源类型只有一个实例：资源分配图算法
- 每个资源类型有多个实例：银行家算法



### 资源分配图算法的流程

- 事先用虚线的声明边表示进程在未来会请求的资源
- 当进程请求资源时，声明边转化为请求边
- 仅当请求边转化为分配边后不会导致资源分配图形成圈时，请求边才会转化为分配边
- 当资源被释放时，分配边转化为声明边



### 银行家算法中各数据结构的含义

- Available：每种资源类型可供申请的数量
- Max：某进程要申请某类型资源的最大数量
- Allocation：某进程已经获得某类型资源的数量
- Need：某进程需要某类型资源的数量



### 资源请求算法的原理

- Request：某进程请求所有类型资源向量
- 若请求资源数量大于需要的数量，则出现超出最大声明的错误情况
- 若请求资源数量大于可供申请的数量，则该进程需要等待
- Available=Available-Request
- Allocation=Allocation+Request
- Need=Need-Request
- 检测当前状态是否安全，若安全，则分配资源；若不安全，则恢复到原来的状态



### 安全状态的原理

- 若存在一个进程序列，对于序列内的每一个进程，其申请的资源能够被该进程之前的进程持有的资源和当前可以获得的资源所满足，则系统处于安全状态



### 安全算法（检测算法）的数据结构和原理

- Work=Available
- Finish=false
- 若Finish[i]=false且Need[i]<Work，则Finish[i]=true且Work=Work+Allocation[i]
- 若当前没有进程同时满足Finish[i]=false和Need[i]<Work，若所有进程的Finish都为true，则系统处于安全状态；否则，处于非安全状态



### 银行家算法的流程

- 列出资源分配状态表（Available, Allocation, Max, Need）
- 安全算法判断当前是否处于安全状态
- 资源请求算法



### 在银行家算法控制下，资源分配状态的变化对安全状态的影响

- 增加Available：安全
- 减少Available：可能不安全
- 增加每个进程的Max：可能不安全
- 减少每个进程的Max：安全
- 增加进程的数量：需要根据新进程的Request和Available用银行家算法判断
- 减少进程的数量：安全



### 死锁检测的分类

- 每个资源类型只有一个实例：等待图算法
- 每个资源类型有多个实例：死锁检测算法



### 死锁的恢复方法与特点

- 进程终止

  1. 停止所有处于死锁状态的进程
  2. 每次停止运行一个进程，直到死锁消除

- 资源抢占

  原则：最小成本选择受害者进程

  方法：回滚——回到安全状态

  不足：饿死——某些进程可能总是被选为受害者
